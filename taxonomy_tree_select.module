<?php
// $Id$


/**
 * Implementation of hook_theme().
 */
function taxonomy_tree_select_theme($existing, $type, $theme, $path) {
  return array(
    'taxonomy_tree_select_nested_lists' => array(
      'arguments' => array('element' => NULL, 'tree' => NULL, 'parent' => NULL, 'tree_temp' => NULL),
    )
  );
}

/**
 * Implementation of hook_form_alter().
 */
function taxonomy_tree_select_form_taxonomy_form_vocabulary_alter(&$form, &$form_state) {
  // Work on vocabulary settings form
  $form['settings']['tags']['#weight'] = $form['settings']['tags']['#weight'] ? $form['settings']['tags']['#weight'] : -2;
  $form['settings']['taxonomy_tree_select'] = array(
    '#type' => 'checkbox',
    '#title' => t('Tree select'),
    '#description' => t('On node form, shows a selectable tree with items of this vocabulary. (Incompatible with "Tags" option)'),
    '#weight' => $form['settings']['tags']['#weight'] + 1,
    '#default_value' => variable_get('vocabulary_' . $form['vid']['#value'] . '_tree_select', 0)
  );
}

/**
 * Implementation of hook_taxonomy().
 */
function taxonomy_tree_select_taxonomy($op, $type, $form_values) {
  if ($form_values['form_id'] == 'taxonomy_form_vocabulary') {
    $key = 'vocabulary_' . $form_values['vid'] . '_tree_select';
    switch ($op) {
      case 'insert':
      case 'update':
        $value = $form_values['taxonomy_tree_select'];
        if ($value) {
          variable_set($key, $value);
        }
        elseif (variable_get($key, 0)) {
          variable_del($key);
        }
        break;
      case 'delete':
        variable_del($key);
        break;
    }
  }
}

/**
 * Implementation of hook_form_alter().
 */
function taxonomy_tree_select_form_alter(&$form, &$form_state, $form_id) {
  global $theme;

  // Work on node form...
  if ($form['#id'] == 'node-form' && $form['taxonomy']) {

    // Walk on all taxonomy fields
    foreach ($form['taxonomy'] as $key => $vocabulary) {
      $tree_select = variable_get('vocabulary_' . $key . '_tree_select', 0);

      // Check if is an tree select vocabulary
      if (is_array($vocabulary) && $tree_select) {

        // Replace select with radios or checkboxes
        $form['taxonomy'][$key] = _taxonomy_tree_select_individualize_selectbox($form['taxonomy'][$key]);
        $form['taxonomy'][$key]['#theme'] = 'taxonomy_tree_select_nested_lists';

        // Add external files
        drupal_add_css(drupal_get_path('module', 'taxonomy_tree_select') . '/taxonomy_tree_select.css');
        // @TODO: Rework on js to match the new server-side generated lists
        // drupal_add_js(drupal_get_path('module', 'taxonomy_tree_select') . '/taxonomy_tree_select.js');
      }
    }
  }
}

/**
 * Render terms in nested lists.
 *
 * @param $element
 *   A array with the form api element of taxonomy terms.
 *
 * @param $tree
 *   A array with the terms generated by taxonomy_get_tree().
 *
 * @param $parent
 *   A numeric value of the tid of the term from the tree should start.
 *   For internal use only.
 *
 * @param $tree_temp
 *   A array with temporary tree for internal use only.
 *
 * @return
 *   Rendered item list with the terms of the element
 */
function theme_taxonomy_tree_select_nested_lists($element, $tree = array(), $parent = 0, $tree_temp = array()) {
  if (!$tree) {
    $vid = $element['#parents'][1];
    $tree = taxonomy_get_tree($vid);
  }
  $list = array();

  foreach ($tree as $term) {
    if ($term->parents[0] == $parent) {

      // @TODO: Make some way to translate the term name
      $element[$term->tid]['#title'] = $term->name;

      $terms[$term->tid] = array(
        'data' => drupal_render($element[$term->tid])
      );
    }
     else {
       $tree_temp[$term->parents[0]][$term->tid] = $term;
     }
   }

   if (is_array($terms)) {
     foreach ($terms as $tid => &$term) {
       if (isset($tree_temp[$tid])) {
         $term['children'] = theme_taxonomy_tree_select_nested_lists($element, $tree_temp[$tid], $tid, $tree_temp);

         $term['class'] = 'expansable expanded';
       }
     }
   }

  if ($parent) {
    return $terms;
  }
  else {
    return theme('item_list', $terms, NULL, 'ul', array('class' => 'taxonomy-tree'));
  }
}

/**
 * Convert an select box element to a series of radio/checkboxes elements.
 *
 * @param $element
 *   A array with the form api element of type "select"
 *
 * @return
 *   Array with the form api element converted to type "radios" or "checkboxes"
 */
function _taxonomy_tree_select_individualize_selectbox($element) {
  if ($element['#type'] == 'select') {
    if ($element['#multiple']) {
      $element['#type'] = 'checkboxes';
    }
    else {
      $element['#type'] = 'radios';

      // Altough #default_value can always be an array even with non-multiple
      // select fields, it needs to be an string with radios fields
      if ($element['#default_value']) {
        $element['#default_value'] = array_shift($element['#default_value']);
      }
      else {
        $element['#default_value'] = '';
      }
    }
  }

  foreach ($element['#options'] as $key => &$option) {

    // Rewrite the options to be used with checkboxes/radios fapi types
    if (is_object($option)) {
      if (is_array($option->option)) {
        list($tid) = array_keys($option->option);
        $term_name  = $option->option[$tid];
      }
      $options[$tid] = $term_name;
    }

    // "None" option from non required vocabularies
    elseif (!$element['#multiple'] && !$key) {
      $options[0] = $option;
    }

    // Remove default options
    unset($element['#options'][$key]);
  }

  $element['#options'] = $options;

  // Remove select-only attributes
  unset(
    $element['#multiple'],
    $element['#size']
  );

  return $element;
}
