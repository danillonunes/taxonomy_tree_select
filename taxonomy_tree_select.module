<?php

/**
 * Implements hook_field_widget_info().
 */
function taxonomy_tree_select_field_widget_info() {
  return array(
    'taxonomy_tree_select' => array(
      'label' => t('Tree Select'),
      'field types' => array('taxonomy_term_reference'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      ),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function taxonomy_tree_select_theme($existing, $type, $theme, $path) {
  return array(
    'taxonomy_tree_select_nested_lists' => array(
      'variables' => array('element' => NULL, 'tree' => NULL, 'parent' => NULL, 'tree_temp' => NULL),
    ),
  );
}

/**
 * Render terms in nested lists.
 *
 * @param $element
 *   A array with the form api element of taxonomy terms.
 *
 * @param $tree
 *   A array with the terms generated by taxonomy_get_tree().
 *
 * @param $parent
 *   A numeric value of the tid of the term from the tree should start.
 *   For internal use only.
 *
 * @param $tree_temp
 *   A array with temporary tree for internal use only.
 *
 * @return
 *   Rendered item list with the terms of the element
 */
function theme_taxonomy_tree_select_nested_lists($variables) {
  $element = $variables['element'];
  $tree = $variables['tree'];
  $parent = $variables['parent'];
  $tree_temp = $variables['tree_temp'];
  global $theme;

  $vid = $element['#parents'][1];

  if (!$tree) {
    $tree = taxonomy_get_tree($vid);
  }
  $list = array();

  foreach ($tree as $term) {
    if ($term->parents[0] == $parent) {

      // @TODO: Make some way to translate the term name / integration with Internationalization UI module
      $element[$term->tid]['#title'] = $term->name;

      $terms[$term->tid] = array(
        'data' => drupal_render_children($element[$term->tid]),
      );
    }
    else {
      $tree_temp[$term->parents[0]][$term->tid] = $term;
    }
  }

  if (is_array($terms)) {
    foreach ($terms as $tid => &$term) {
      if (isset($tree_temp[$tid])) {
        $term['children'] = theme('taxonomy_tree_select_nested_lists', $element, $tree_temp[$tid], $tid, $tree_temp);

        $term['class'] = 'expansable expanded';
      }
      else {
        $term['class'] = 'leaf';
      }
    }
  }

  if ($parent) {
    return $terms;
  }
  else {
    $tree_classes[] = 'taxonomy-tree';
    $tree_classes[] = sprintf('taxonomy-tree-theme-%s', $theme);

    // There's no user interface for this option, you can by enable it by
    // manually add an variable vocabulary_%vid_tree_select_show_input
    // with the value 0.
    if (!variable_get('vocabulary_' . $vid . '_tree_select_show_input', 1)) {
      $tree_classes[] = 'taxonomy-tree-hidden-input';
    }

    return theme('item_list', array('items' => $terms, 'title' => NULL, 'type' => 'ul', 'attributes' => array('class' => implode(' ', $tree_classes))));
  }
}

/**
 * Convert an select box element to a series of radio/checkboxes elements.
 *
 * @param $element
 *   A array with the form api element of type "select"
 *
 * @return
 *   Array with the form api element converted to type "radios" or "checkboxes"
 */
function _taxonomy_tree_select_individualize_selectbox($element) {
  if ($element['#type'] == 'select') {
    if ($element['#multiple']) {
      $element['#type'] = 'checkboxes';
    }
    else {
      $element['#type'] = 'radios';

      // Altough #default_value can always be an array even with non-multiple
      // select fields, it needs to be an string with radios fields
      if ($element['#default_value']) {
        $element['#default_value'] = array_shift($element['#default_value']);
      }
      else {
        $element['#default_value'] = '';
      }
    }
  }

  foreach ($element['#options'] as $key => &$option) {

    // Rewrite the options to be used with checkboxes/radios fapi types
    if (is_object($option)) {
      if (is_array($option->option)) {
        list($tid) = array_keys($option->option);
        $term_name  = $option->option[$tid];
      }
      $options[$tid] = $term_name;
    }

    // "None" option from non required vocabularies
    elseif (!$element['#multiple'] && !$key) {
      $options[0] = $option;
    }

    // Remove default options
    unset($element['#options'][$key]);
  }

  $element['#options'] = $options;

  // Remove select-only attributes
  unset(
    $element['#multiple'],
    $element['#size']
  );

  return $element;
}

/**
 * Add external files.
 *
 * This is done in a after build function to make sure this files will be
 * loaded even when the hook_form_alter doesn't run (i.e. in a form error).
 */
function _taxonomy_tree_select_add_external_files($form, $form_state) {
  drupal_add_css(drupal_get_path('module', 'taxonomy_tree_select') . '/taxonomy_tree_select.css');
  drupal_add_js(drupal_get_path('module', 'taxonomy_tree_select') . '/taxonomy_tree_select.js');

  return $form;
}
